###########################
#   MANDELBROT ON A GPU   #
###########################
#
# Let's render the mandelbrot set!
#
# The steps are as follows:
#   1. Set up mesh of grid points to render
#   2. Loop over all grid points
#   3. Parallel process num_iters before divergence,
#      according to the Mandelbrot relation, z = z^2 + z_0.
#   4. Send num_iters to HDMI module for colorized rendering.

# CONVENTIONS:
#   - There are 16 private registers for the controller.
#   - Register 0 is always set all to zeros.
#   - Register 1 is reserved as a return line.
#   - There are 2 FMA blocks available for parallelism. [UPDATE TO 16]
#   - All FMA operations are fixed-point with 16 bits.
#   - Negative numbers are represented as two's complement.
#   - There are 504000 bits available in GPU main memory. [UPDATE BRAM TO ACCOUNT]
#   - Main memory is split into lines of 6 numbers each. [UPDATE TO 3*FMA_COUNT]
#   - The HDMI display expects resolution of 160 x 320, with 4 bits per pixel.
#   - The bits represent num_iters / 8, so that the range [0, 127] is represented.

# Step 1: Set up mesh of grid points to render
xor 0 0               # zero out register 0
addi 2 0 160          # HEIGHT = 160: set register 2 to 160
addi 3 0 320          # WIDTH = 320: set register 3 to 320
addi 4 0 -2f          # X_MIN = -2 (f notation compiles into fixed-point)
#addi 5 0 0.0078125f  # DX = 2^(-7) = 0.0078125 so that X_MAX = 0.5 
addi 6 0 -1.25f       # Y_MIN = -1.25 (f notation compiles into fixed-point)
#addi 7 0 0.015625f   # DY = 2^(-6) = 0.015625 so that Y_MAX = 1.25
addi 5 0 127          # MAX_ITERS = 127 (register 5)

# Step 2: Loop over all grid points
#   - Use register 8 as x_counter
#   - Use register 9 as y_counter
#   - Use register 10 as x_val
#   - Use register 11 as y_val
#   - Use register 12 as minus_y_val
#   - Use register 14 as addr_for_iters
#   - Increment x_val and y_val by DX and DY
# We will implement the following pseudocode:
#   for (x_counter = 0; x_counter < WIDTH; x_counter++) {
#     for (y_counter = 0; y_counter < HEIGHT; y_counter++) {
#        // load Mandelbrot coordinates into main memory
#     }
#   }

xor 14 14              # zero out register 14 (addr_for_iters

# <FOR LOOP X>

xor 8 8                # set x_counter = 0
addi 10 4 0            # set x_val to X_MIN

bge 2 8                # branch if WIDTH >= x_counter [JUMP MARKER 0]
jump ____              # jump past (1)

# <FOR LOOP X: INNER LOGIC>

# <FOR LOOP Y>

xor 9 9                # zero out register 9
addi 11 6 0            # set y_val to Y_MIN
addi 12 6 0            # set minus_y_val to -Y_MIN

bge 3 9                # branch if HEIGHT >= y_counter [JUMP MARKER 2]
jump ____              # jump past (3)

# <FOR LOOP Y: INNER LOGIC>

# In this inner nested for loop, we have access to the following variables:
#   x_counter (reg 8), y_counter (reg 9), x_val (reg 10), y_val (reg 11)
# We will place these values into memory in such a way that we can enter one
# final for loop, in which we will compute num_iters.

# We will always perform Mandelbrot calculations in lines 1-3 of memory.
# Mandelbrot results will go in the last XXXX bits of memory.
sma 1        # set memory address to line 1
# Let's compute x*x + x_0 (base case) (TEMP x_{i+1})
load 0 10    # load x_val into FMA_1 "a"
load 1 10    # load x_val into FMA_1 "b"
load 2 10    # load x_val into FMA_1 "c"
load 3 10    # load x_val into FMA_2 "a"
load 4 10    # load x_val into FMA_2 "b"
load 5 10    # load x_val into FMA_2 "c"
sendl
writeb 1 1 1 # send line 1 to the FMAs! (replace_c, fma_valid_out)
# Let's compute x*x - y*y + y_0 (FULL x_{i+1}
load 0 12    # load -y_val into FMA_1 "a" (reg 12)
load 1 10    # load y_val into FMA_1 "b"
load 2 0     # load 0 into FMA_1 "c"
load 3 12    # load -y_val into FMA_2 "a" (reg 12)
load 4 10    # load x_val into FMA_2 "b"
load 5 0     # load 0 into FMA_2 "c"
sendl
writeb 1 0 1 # send line 1 to the FMAs! (not replace_c, fma_valid_out)
# Let's compute 2*x*y + y_0 (FULL y_{i+1})
load 0 13    # load 2*x_val into FMA_1 "a" (reg 13)
load 1 11    # load y_val into FMA_1 "b"
load 2 11    # load y_val into FMA_1 "c"
load 3 13    # load 2*x_val into FMA_2 "a" (reg 13)
load 4 11    # load y_val into FMA_2 "b"
load 5 11    # load y_val into FMA_2 "c"
sendl
writeb 1 1 1 # send line 1 to the FMAs again! (replace_c, fma_valid_out)
# NOW: the write buffer will send THREE values for each FMA:
#   1. x_{i+1} temp
#   2. x_{i+1} full
#   3. y_{i+1} full
# Shuffle should select out (x_{i+1} full, y_{i+1} full).
# Shuffle should also select (2x_{i+1} full and -y_{i+1} full).

# RESERVE line 3 for whether that point has diverged so far.

# INSERT CHECK HERE FOR WHETHER WE DIVERGED
op_or 1     # record whether points diverged by iteration 1

# Register 15 will hold the iter value
addi 15 0 1   # iters = 1: set register 15 to value 1
bge 15 5      # if iters >= 127
jump ____     # jump to (5) [JUMP MARKER 6]

# <mandelbrot for loop>

# Three steps:
# 1. Now we pull (x, y) values out of fma_write_buffer via loadb with shuffle arguments.
# 2. We compute the next iteration of the Mandelbrot formula.
# 3. Then we OP_OR to record any new divergences.

# Let's compute x*x + x_0 (base case) (TEMP x_{i+1})
loadb 1 2 2 0  # set line 1 of memory to "x_i x_i 0"
load 2 10      # load x_val = x_0 into FMA_1 "c" 
load 5 10      # load x_val = x_0 into FMA_2 "c"
sendl
writeb 1 1 1   # send line 1 to FMAs! (replace_c, fma_valid_out)

# Let's compute x*x - y*y + y_0 (FULL x_{i+1}
loadb 1 -3 3 0 # set line 1 of memory to "-y_i y_i 0"
sendl
writeb 1 0 1   # send line 1 to FMAs! (not replace_c, fma_valid_out)

# Let's compute 2*x*y + y_0 (FULL y_{i+1})
loadb 1 4 3 0  # set line 1 of memory to "2*x_i y_i 0"
load 2 11      #


# </mandelbrot for loop>

addi 15 15 1  # increment iters by 1
jump ____     # jump to (6) [JUMP MARKER 5]

# do a register computation to create a register that is col-major order for the frame buffer, then write to that register (14)
# addr = x_count * WIDTH + y_count
send_iters ___14    # send to line addr_to_send of frame buffer the mandelbrot_iters

# </FOR LOOP Y: INNER LOGIC>

addi 11 11 0.015625f   # increment y_val by DY  (FMA_1 DONE)
addi 11 11 0.015625f   # increment y_val by DY (twice for two FPGAs)
addi 14 14 2           # increment addr_for_iters by FMA_COUNT = 2
addi 9 9 1             # increment y_counter by 1
jump ____              # jump to (2) [JUMP MARKER 3]

# </FOR LOOP Y>

# </FOR LOOP X: INNER LOGIC>

addi 10 10 0.0078125f  # increment x_val by DX
addi 8 8 1             # increment x_counter by 1
jump ____              # jump to (0) [JUMP MARKER 1]

# </FOR LOOP X>
















end
