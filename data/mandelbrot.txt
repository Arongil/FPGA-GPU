###########################
#   MANDELBROT ON A GPU   #
###########################
#
# Let's render the mandelbrot set!
#
# The steps are as follows:
#   1. Set up mesh of grid points to render
#   2. Loop over all grid points
#   3. Parallel process num_iters before divergence,
#      according to the Mandelbrot relation, z = z^2 + z_0.
#   4. Send num_iters to HDMI module for colorized rendering.

# CONVENTIONS:
#   - There are 16 private registers for the controller.
#   - Register 0 is always set all to zeros.
#   - Register 1 is reserved as a return line.
#   - There are 2 FMA blocks available for parallelism. [UPDATE TO 16]
#   - All FMA operations are fixed-point with 16 bits.
#   - Negative numbers are represented as two's complement.
#   - There are 504000 bits available in GPU main memory. [UPDATE BRAM TO ACCOUNT]
#   - Main memory is split into lines of 6 numbers each. [UPDATE TO 3*FMA_COUNT]
#   - The HDMI display expects resolution of 160 x 320, with 4 bits per pixel.
#   - The bits represent num_iters / 8, so that the range [0, 127] is represented.

# Step 1: Set up mesh of grid points to render
xor 0 0               # zero out register 0
addi 2 0 160          # HEIGHT = 160: set register 2 to 160
addi 3 0 320          # WIDTH = 320: set register 3 to 320
addi 4 0 -2f          # X_MIN = -2 (f notation compiles into fixed-point)
#addi 5 0 0.0078125f  # DX = 2^(-7) = 0.0078125 so that X_MAX = 0.5 
addi 6 0 -1.25f       # Y_MIN = -1.25 (f notation compiles into fixed-point)
#addi 7 0 0.015625f   # DY = 2^(-6) = 0.015625 so that Y_MAX = 1.25
addi 5 0 127          # MAX_ITERS = 127 (register 5)

# Step 2: Loop over all grid points
#   - Use register 8 as x_counter
#   - Use register 9 as y_counter
#   - Use register 10 as x_val
#   - Use register 11 as y_val
#   - Use register 12 as minus_y_val
#   - Use register 14 as addr_for_iters
#   - Increment x_val and y_val by DX and DY
# We will implement the following pseudocode:
#   for (x_counter = 0; x_counter < WIDTH; x_counter++) {
#     for (y_counter = 0; y_counter < HEIGHT; y_counter++) {
#        // load Mandelbrot coordinates into main memory
#     }
#   }

xor 14 14              # zero out register 14 (addr_for_iters

# <FOR LOOP X>

xor 8 8                # set x_counter = 0
addi 10 4 0            # set x_val to X_MIN

bge 2 8                # branch if WIDTH >= x_counter [JUMP MARKER 0]
jump ____              # jump past (1)

# <FOR LOOP X: INNER LOGIC>

# <FOR LOOP Y>

xor 9 9                # zero out register 9
addi 11 6 0            # set y_val to Y_MIN
addi 12 6 0            # set minus_y_val to -Y_MIN

bge 3 9                # branch if HEIGHT >= y_counter [JUMP MARKER 2]
jump ____              # jump past (3)

# <FOR LOOP Y: INNER LOGIC>

# In this inner nested for loop, we have access to the following variables:
#   x_counter (reg 8), y_counter (reg 9), x_val (reg 10), y_val (reg 11)
# We will place these values into memory in such a way that we can enter one
# final for loop, in which we will compute num_iters.

# We will always perform Mandelbrot calculations in lines 1-3 of memory.
# Mandelbrot results will go in the last XXXX bits of memory.
sma 1        # set memory address to line 1
# First, output just y_0 into both FMAs for later use.
load 0 0 0           # load 0 into FMA "a" values (diff 0 per FMA)
load 1 0 0           # load 0 into FMA "b" values (diff 0 per FMA)
load 2 11 0.015625f  # load y_0 into FMA_1 "c"    (diff DY per FMA)
write 1 1    # send loaded buffer to the FMAs! (replace_c, fma_valid_out)
# Next, let's ouput just x_0 into both FMAs for later use.
load 0 0 0   # load 0 into FMA "a" values
load 1 0 0   # load 0 into FMA "b" values
load 2 10 0  # load x_val into FMA "c" values
write 1 1    # send loaded buffer to the FMAs! (replace_c, fma_valid_out)
# Finally, output just y_0 again into both FMAs for later use.
load 0 0 0           # load 0 into FMA "a" values (diff 0 per FMA)
load 1 0 0           # load 0 into FMA "b" values (diff 0 per FMA)
load 2 11 0.015625f  # load y_0 into FMA_1 "c"    (diff DY per FMA)
write 1 1    # send loaded buffer to the FMAs! (replace_c, fma_valid_out)

# NOW: the write buffer will send THREE values for each FMA:
#   1. y_0
#   2. x_i
#   3. y_i
# Shuffle should select out (x_i, y_i).
# Shuffle should also select (2x_i, -y_i).

# Check whether we have diverged
or 0     # record whether points diverged by iteration 0

# Register 15 will hold the iter value
addi 15 0 1   # iters = 1: set register 15 to value 1
bge 15 5      # if iters >= 127
jump ____     # jump to (5) [JUMP MARKER 6]

# <mandelbrot for loop>

# Three steps:
# 1. Now we pull (x, y) values out of fma_write_buffer via loadb with shuffle arguments.
# 2. We compute the next iteration of the Mandelbrot formula.
# 3. Then we OP_OR to record any new divergences.

# First, we preserve the first FMA output as again y_0.
loadb 1 0 0 1  # set line 1 of memory to "0 0 y_0" (0 0 1)
write 1 1      # send loaded buffer to FMAs! (replace_c, fma_valid_out)

# Let's compute x*x + x_0 (TEMP x_{i+1})
loadb 1 2 2 0  # set line 1 of memory to "x_i x_i 0" (2 2 0)
load 2 10 0    # load x_val = x_0 into "c" values
write 1 0      # send loaded buffer to FMAs! (replace_c, not fma_valid_out)

# Let's compute x*x - y*y + y_0 (FULL x_{i+1})
loadb 1 -3 3 0 # set line 1 of memory to "-y_i y_i 0"
write 0 1   # send loaded buffer to FMAs! (not replace_c, fma_valid_out)

# Let's compute 2*x*y + y_0 (FULL y_{i+1})
loadb 1 4 3 1  # set line 1 of memory to "2*x_i y_i y_0"
write 1 1      # send loaded buffer to FMAs! (replace_c, fma_valid_out)

# NOW: the write buffer will send THREE values for each FMA:
#   1. y_0
#   2. x_{i+1}
#   3. y_{i+1}

or 15    # record whether points have diverged by iteration iter (reg 15)

# </mandelbrot for loop>

addi 15 15 1  # increment iters by 1
jump ____     # jump to (6) [JUMP MARKER 5]

# SEND THE MANDEBROT_ITERS ARRAY TO FRAME BUFFER AT THE PROPER ADDRESS

# do a register computation to create a register that is col-major order for the frame buffer, then write to that register (14)
# addr = x_count * WIDTH + y_count
send_iters ___14    # send to line addr_to_send of frame buffer the mandelbrot_iters

# </FOR LOOP Y: INNER LOGIC>

addi 11 11 0.015625f   # increment y_val by DY  (FMA_1 DONE)
addi 11 11 0.015625f   # increment y_val by DY (twice for two FPGAs)
addi 14 14 2           # increment addr_for_iters by FMA_COUNT = 2
addi 9 9 1             # increment y_counter by 1
jump ____              # jump to (2) [JUMP MARKER 3]

# </FOR LOOP Y>

# </FOR LOOP X: INNER LOGIC>

addi 10 10 0.0078125f  # increment x_val by DX
addi 8 8 1             # increment x_counter by 1
jump ____              # jump to (0) [JUMP MARKER 1]

# </FOR LOOP X>
















end
